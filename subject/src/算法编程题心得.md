1. 在遇到求数组下标索引、链表索引时，别忘了可以使用hash思想，可通过hashmap快速获得索引值等

2. 如果算法是通过条件控制数组下标索引增减，尽量使用while循环和if条件进行控制，而不使用for循环进行自增自减等操作，可以避免一些不必要的编码错误。

3. 在处理大数时，要格外小心中间变量的溢出，而中间变量的溢出可提前进行判断。如果temp = rev*10+pop会溢出，那么rev必然大于Integer.MAX_VALUE/10。于是便可通过rev提前进行判断。

4. 对于一个算法题，首先就是识别问题，在找到问题的直接解决方案后，看存不存在一模一样的更小的子问题，如果存在看能不能使用贪心或者动态规划思想。动态规划主要就是找到子问题，能够通过记忆化数组去存储子问题的结果，最终的大问题便可通过小的子问题来快速解决。

5. 如果是数组的话就是：数组.length属性;
   如果是字符串的话就是：字符串.length()方法;
   如果是集合的话就是：集合.size()方法 

6. 不要在while循环中使用自增自减操作，很容易造成难以发觉的数组越界错误。

7. 当你觉得一个似乎无从下手的问题的时候，不妨尝试去寻找或制造一种“规律”，排序是手段之一。

8. 有很多受约束的二元组合问题，受约束是指很多二元组合根据实际目的来看，实际上没有必要进行遍历，都可以通过双指针法，根据实际结果和条件往中间夹，实现线性时间内的二元组合的遍历。

9. 在处理链表类型的题时，当发现算法需要单独处理第一个结点，不好写进循环时，可以考虑设置头结点，这样就保证了处理第一个节点和后面的节点的时候设计的算法相同,实现程序的高效性。

  另外在对链表的节点进行交换位置时，一定要注意，节点的交换主要是对节点的next进行操作，而且要注意保存前面的节点，而不是节点本身的交换，比如p和q两个交换，并不是说swap(p,q),而是p.next = q.next;	q.next = p。

  还得注意的是，空指针节点是没有next节点的，若节点p有可能是null的话，那么编写程序的过程中p.next就尽量避免出现，如果实在避免不了可以使用如下方法		if(p!=null&&p.next!=null)	这样就可以事先判断p节点是否为空，而不会报p.next的空指针异常。

10. 类似于这种数组的长度和值的判断，if(i<nums.length&&nums[i]==val)，要首先判断长度，这样才能避免数组越界，
    而不要写成 if(nums[i]==val&&i<nums.length)。

11. 在java中要对字符串进行遍历，可以不用charAt函数，可以采用char[] ca = s.toCharArray();	将其转换为字符数组，在直接对其进行	
for(char a : ca) 循环遍历即可，这样还可以避免数组越界。

12. 先想边界条件的测试用例，对特殊情况作出处理，再进行程序编写，写完之后在用边界条件测试用例模拟一遍

13. 字符c转整数，直接int num = c-'0'

14. 能够用数组解决的问题，就不要用list，对数组的操作是O(1)的时间复杂度，但是对list的操作，其内部就要涉及多个操作，会造成函数的多重调用，时间复杂度就会上升。

15. 尽量将等式除法判断转换为等式乘法判断，这样就可以避免除数为0的情况。

16. 滑动窗口，可以通过保存下一窗口的前缀来优化时间

17. 统计数组且按最后统计出的大小进行排列，考虑TreeMap（红黑树）


交叉验证是一种划分数据集的手段，而具体在选择模型时的性能评价还是得通过损失函数来体现，比如用于回归评价的MSE等，用于分类的对数损失函数等。
可以使用交叉验证来估计一个模型的泛化能力。如果一个模型在训练集上表现良好，通过交叉验证指标却得出其泛化能力很差，那么你的模型就是过拟合了。如果在这两方面都表现不好，那么它就是欠拟合了。这种方法可以告诉我们，你的模型是太复杂还是太简单了。
一般情况下，训练过程使用的损失函数和测试过程使用的评价函数是不一样的。除了正则化，还有一个不同：训练时的损失函数应该在优化过程中易于求导，而在测试过程中，评价函数更应该接近最后的客观表现。一个好的例子：在分类训练中我们使用对数损失（马上我们会讨论它）作为损失函数，但是我们却使用精确率/召回率来作为它的评价函数。
