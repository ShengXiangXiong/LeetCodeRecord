1. 0-1 背包： 待挑选的物品有且仅有一个，可以选择也可以不选择。
        整体模板都是外层按物品规模进行阶段循环，内层则按容量进行容量状态转移（下面给出空间优化的0-1背包模板，
        因为其只会受前一阶段的影响，故只需要保存前一阶段的状态）
        for item in items:
            for i from cap to 0:    //容量必须要从大到小，这样才不会造成 大cap 被 小cap影响
                if(i>=item.weight){
                    dp[i] = ...         //根据具体问题定义
                }

        最大价值类0-1背包：判断最大能装多少价值
            if(i>=item.weight){
                dp[i] = max(dp[i],dp[i-item.weight]+item.value)
            }

        装箱类0-1背包：判断是否能装满
            前置条件dp[0] = true (必须，因为0代表无论如何都可以装满0，而且这也会影响后续的状态)
            if(i>=item.weight){
                dp[i] = dp[i] || dp[i-item.weight]
            }


2.完全背包：待挑选的物品有无穷多个。
            所以这里我们外层对容量cap循环，这样就可以保证每个阶段的值都是从所有物品得出的，进行阶段状态转移，
            内层则是循环所有物品，整体模板如下：
            for i in cap:
                for item in items:
                    dp[i] = ...         //根据具体问题定义

            最大价值类完全背包，装箱类完全背包  状态转移完全同上


3.多重背包：待挑选的物品有确定个数n，不是任意个，也不是只有1个
        （1）考虑转换成0-1背包问题，把第i种物品换成n[i]件01背包中的物品，则得到了物品数为Σn[i]的01背包问题
            ——时间复杂度O（cap*Σn[i]）

            优化：比如对于第i个物品有n[i]=7，最初我们是想分解成7个一模一样的物品i，其价值重量都一样，于是就转换成了0-1背包，
            其原理就是模拟任意选x个i物品且 x <= n[i]
            那我们可以考虑以下是否能够压缩状态，使分解后的物品尽量少但是能够模拟所有取物品i小于n[i]的可能。
            答案是肯定的
            把它的件数n[i]用 二进制分解 成若干个件数的集合，这里面数字可以组合成任意小于等于n[i]的件数，而且不会重复，
            之所以叫二进制分解，是因为这样分解可以用数字的二进制形式来解释。
            比如：7的二进制 7 = 111 它可以分解成 001(1) 010(2) 100(4) 这三个数可以组合成任意小于等于7 的数，
            而且每种组合都会得到不同的数，然后再将其价值和重量乘以其分解系数，这样就将数量转化为1了，成为了0-1问题。
            比如物品item[i]，其item[i].nums = 7;     item[i].weight = w;    item[i].value = v;
            通过二进制分解，就可已得到分解后的3个物品:
                    item[i1]——item[i1].weight = 1*w     item[i1].value = 1*v;
                    item[i2]——item[i2].weight = 2*w     item[i1].value = 2*v;
                    item[i3]——item[i3].weight = 4*w     item[i1].value = 4*v;
            这3个物品的0-1选择，就代表了对原item的个数选择，比如选择item[i1]，就代表选择了1个item[i];
            选择item[i2]就代表了选择2个item[i]；选择item[i1]和item[i2]就代表了选择3个item[i]。

            因此说基于这种思想去把多件物品转换为，多种一件物品，就可用01 背包求解了，所以关键点就在于二进制分解。

            //二进制分解，既然二进制，自然想到右移位运算
            //假设item的数量为k[i]
            int count = 0;
            for item in items:
                while(k[i]>=0){
                    int k[i] = k[i]>>1;
                    item[count++].weight = k[i]*item[i].weight
                    item[count++].value = k[i]*item[i].value
                }
            }
            ——时间复杂度O（cap*logΣn[i]）

        （2）仍以完全背包问题思考，只是加了一个限制条件，也就是说对于第i种物品有n[i]+1种策略：取0件，取1件……取item.nums件
            因此有状态转移方程
            for 0<=k<=item.nums{
                if(i>=k*item.weight){
                    dp[i] = max(dp[i],dp[i-k*item.weight]+k*item.value)
                }
            }
            ——时间复杂度O（cap*Σn[i]）



4.含有负数的背包：
    其实只需要将所有的物品增加一个offset偏移量，使其值变为正即可。

5.含有实数的背包：（涉及到精度的问题）
    也很好解决，定义一个误差范围，只要认定小于某一个误差，即可接受。


